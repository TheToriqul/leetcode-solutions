{
  "two-sum_c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    // Set return size to 2 as we need to return 2 indices\n    *returnSize = 2;\n    \n    // Allocate memory for result array\n    int* result = (int*)malloc(2 * sizeof(int));\n    \n    // Handle edge cases\n    if (nums == NULL || numsSize < 2) {\n        return result;\n    }\n    \n    // Use nested loop to find the pair\n    for (int i = 0; i < numsSize - 1; i++) {\n        for (int j = i + 1; j < numsSize; j++) {\n            // Check if current pair sums to target\n            if (nums[i] + nums[j] == target) {\n                result[0] = i;\n                result[1] = j;\n                return result;\n            }\n        }\n    }\n    \n    return result;\n}",
  "two-sum_cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // Hash map to store number and its index\n        unordered_map<int, int> numMap;\n        \n        // Iterate through the array\n        for (int i = 0; i < nums.size(); i++) {\n            // Calculate the complement needed\n            int complement = target - nums[i];\n            \n            // Check if complement exists in hash map\n            if (numMap.find(complement) != numMap.end()) {\n                // Return current index and complement's index\n                return {numMap[complement], i};\n            }\n            \n            // If complement not found, add current number and index to hash map\n            numMap[nums[i]] = i;\n        }\n        \n        // No solution found (though problem guarantees a solution exists)\n        return {};\n    }\n};",
  "design-hashmap_python3": "class MyHashMap:\n    def __init__(self):\n        self.map = dict()\n\n    def put(self, key: int, value: int) -> None:\n        self.map[key] = value\n\n    def get(self, key: int) -> int:\n        return self.map[key] if key in self.map else -1\n\n    def remove(self, key: int) -> None:\n        if key in self.map: del self.map[key]\n\n# Your MyHashMap object will be instantiated and called as such:\n# obj = MyHashMap()\n# obj.put(key,value)\n# param_2 = obj.get(key)\n# obj.remove(key)",
  "minimum-number-of-steps-to-make-two-strings-anagram_python3": "class Solution:\n    def minSteps(self, s: str, t: str) -> int:\n        smp = {}\n        tmp = {}\n        cnt = 0\n\n        for a in s:\n            smp[a] = smp.get(a, 0) + 1\n\n        for a in t:\n            tmp[a] = tmp.get(a, 0) + 1\n\n        for key, value in smp.items():\n            if key in tmp:\n                if value == tmp[key]:\n                    cnt += value\n                else:\n                    cnt += min(value, tmp[key])\n\n        return len(s) - cnt        ",
  "design-linked-list_python3": "class ListNode:\n    def __init__(self, val):\n        self.val = val\n        self.next = None\n        \nclass MyLinkedList(object):\n    def __init__(self):\n        self.head = None\n        self.size = 0\n\n    def get(self, index: int) -> int:\n        if index < 0 or index >= self.size:\n            return -1\n\n        current = self.head\n\n        for _ in range(0, index):\n            current = current.next\n\n        return current.val\n\n    def addAtHead(self, val: int) -> None:\n        self.addAtIndex(0, val)\n\n    def addAtTail(self, val: int) -> None:\n        self.addAtIndex(self.size, val)\n\n    def addAtIndex(self, index: int, val: int) -> None:\n        if index > self.size:\n            return\n\n        current = self.head\n        new_node = ListNode(val)\n\n        if index <= 0:\n            new_node.next = current\n            self.head = new_node\n        else:\n            for _ in range(index - 1):\n                current = current.next\n            new_node.next = current.next\n            current.next = new_node\n\n        self.size += 1\n\n    def deleteAtIndex(self, index: int) -> None:\n        if index < 0 or index >= self.size:\n            return\n\n        current = self.head\n\n        if index == 0:\n            self.head = self.head.next\n        else:\n            for _ in range(0, index - 1):\n                current = current.next\n            current.next = current.next.next\n\n        self.size -= 1\n        \n\n\n# Your MyLinkedList object will be instantiated and called as such:\n# obj = MyLinkedList()\n# param_1 = obj.get(index)\n# obj.addAtHead(val)\n# obj.addAtTail(val)\n# obj.addAtIndex(index,val)\n# obj.deleteAtIndex(index)",
  "maximum-difference-between-node-and-ancestor_python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        m = [0]\n        self.dfs(root, m)\n        return m[0]\n\n    def dfs(self, root, m):\n        if not root:\n            return float('inf'), float('-inf')\n\n        left = self.dfs(root.left, m)\n        right = self.dfs(root.right, m)\n\n        min_val = min(root.val, min(left[0], right[0]))\n        max_val = max(root.val, max(left[1], right[1]))\n\n        m[0] = max(m[0], max(abs(min_val - root.val), abs(max_val - root.val)))\n\n        return min_val, max_val\n        ",
  "remove-nodes-from-linked-list_python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def removeNodes(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None:\n            return None\n        head.next = self.removeNodes(head.next)\n        if head.next and head.val < head.next.val:\n            return head.next\n        return head         ",
  "merge-two-sorted-lists_python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n\n        while list1 is not None and list2 is not None:\n            if list1.val <= list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            \n            tail= tail.next\n\n        tail.next = list2 if list1 is None else list1\n        return dummy.next",
  "delete-the-middle-node-of-a-linked-list_python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        if head is None or head.next is None:\n            return None\n\n        slow = head\n        fast = head.next.next\n\n        while fast is not None and fast.next is not None:\n            slow = slow.next\n            fast = fast.next.next\n        slow.next = slow.next.next\n        return head        "
}