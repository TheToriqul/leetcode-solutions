{
  "maximum-difference-between-node-and-ancestor_python3": "# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def maxAncestorDiff(self, root: Optional[TreeNode]) -> int:\n        m = [0]\n        self.dfs(root, m)\n        return m[0]\n\n    def dfs(self, root, m):\n        if not root:\n            return float('inf'), float('-inf')\n\n        left = self.dfs(root.left, m)\n        right = self.dfs(root.right, m)\n\n        min_val = min(root.val, min(left[0], right[0]))\n        max_val = max(root.val, max(left[1], right[1]))\n\n        m[0] = max(m[0], max(abs(min_val - root.val), abs(max_val - root.val)))\n\n        return min_val, max_val",
  "merge-two-sorted-lists_python3": "# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        tail = dummy\n\n        while list1 is not None and list2 is not None:\n            if list1.val <= list2.val:\n                tail.next = list1\n                list1 = list1.next\n            else:\n                tail.next = list2\n                list2 = list2.next\n            \n            tail= tail.next\n\n        tail.next = list2 if list1 is None else list1\n        return dummy.next",
  "two-sum_c": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* twoSum(int* nums, int numsSize, int target, int* returnSize) {\n    // Set return size to 2 as we need to return 2 indices\n    *returnSize = 2;\n    \n    // Allocate memory for result array\n    int* result = (int*)malloc(2 * sizeof(int));\n    \n    // Handle edge cases\n    if (nums == NULL || numsSize < 2) {\n        return result;\n    }\n    \n    // Use nested loop to find the pair\n    for (int i = 0; i < numsSize - 1; i++) {\n        for (int j = i + 1; j < numsSize; j++) {\n            // Check if current pair sums to target\n            if (nums[i] + nums[j] == target) {\n                result[0] = i;\n                result[1] = j;\n                return result;\n            }\n        }\n    }\n    \n    return result;\n}",
  "two-sum_cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // Hash map to store number and its index\n        unordered_map<int, int> numMap;\n        \n        // Iterate through the array\n        for (int i = 0; i < nums.size(); i++) {\n            // Calculate the complement needed\n            int complement = target - nums[i];\n            \n            // Check if complement exists in hash map\n            if (numMap.find(complement) != numMap.end()) {\n                // Return current index and complement's index\n                return {numMap[complement], i};\n            }\n            \n            // If complement not found, add current number and index to hash map\n            numMap[nums[i]] = i;\n        }\n        \n        // No solution found (though problem guarantees a solution exists)\n        return {};\n    }\n};"
}